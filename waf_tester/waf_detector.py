import re
import requests
from typing import Dict, List, Optional, Tuple
import yaml
import json


class WAFDetector:
    def __init__(self, config_path: str = "config.yaml"):
        with open(config_path, 'r') as f:
            self.config = yaml.safe_load(f)

        self.waf_signatures = self.load_waf_signatures()
        self.detected_wafs = []

    def load_waf_signatures(self) -> Dict:
        """Загрузка сигнатур известных WAF"""
        signatures = {
            "Cloudflare": {
                "headers": {
                    "server": ["cloudflare"],
                    "cf-ray": [".*"],
                    "cf-cache-status": [".*"]
                },
                "response_body": [
                    "Cloudflare Ray ID",
                    "Attention Required! | Cloudflare"
                ],
                "response_codes": [403, 503]
            },
            "ModSecurity": {
                "headers": {
                    "server": ["mod_security", "modsecurity"],
                },
                "response_body": [
                    "ModSecurity",
                    "This error was generated by Mod_Security"
                ],
                "response_codes": [403, 406]
            },
            "Akamai": {
                "headers": {
                    "server": ["akamai"],
                    "x-akamai-transformed": [".*"]
                },
                "response_body": [
                    "Akamai",
                    "Reference #"
                ]
            },
            "AWS WAF": {
                "headers": {
                    "x-amzn-requestid": [".*"],
                    "x-amz-id-2": [".*"]
                },
                "response_body": [
                    "Request blocked",
                    "AWS WAF"
                ]
            },
            "Imperva": {
                "headers": {
                    "x-cdn": ["imperva"],
                    "server": ["imperva"]
                },
                "response_body": [
                    "imperva",
                    "security.imperva.com"
                ]
            },
            "F5 BIG-IP": {
                "headers": {
                    "server": ["big-ip", "f5"],
                    "x-wa-info": [".*"]
                },
                "response_body": [
                    "BIG-IP",
                    "F5",
                    "The requested URL was rejected"
                ]
            },
            "FortiWeb": {
                "headers": {
                    "server": ["fortiweb"],
                    "x-fortiweb-*": [".*"]
                },
                "response_body": [
                    "FortiWeb",
                    "Fortinet"
                ]
            },
            "Citrix Netscaler": {
                "headers": {
                    "server": ["netscaler"],
                    "ns-cache": [".*"]
                },
                "response_body": [
                    "NetScaler",
                    "Citrix"
                ]
            },
            "Barracuda": {
                "headers": {
                    "server": ["barracuda"]
                },
                "response_body": [
                    "Barracuda",
                    "barracudanetworks.com"
                ]
            },
            "Sucuri": {
                "headers": {
                    "server": ["sucuri"],
                    "x-sucuri-id": [".*"],
                    "x-sucuri-cache": [".*"]
                },
                "response_body": [
                    "Sucuri",
                    "Access Denied - Sucuri"
                ]
            }
        }

        return signatures

    def detect(self, url: str, method: str = "GET",
               headers: Dict = None, timeout: int = 10) -> Dict:
        """Детектирование WAF на целевой системе"""

        if headers is None:
            headers = {
                'User-Agent': 'WAF-Detector/1.0'
            }

        try:
            response = requests.request(
                method=method,
                url=url,
                headers=headers,
                timeout=timeout,
                allow_redirects=False
            )

            return self.analyze_response(response)

        except requests.exceptions.RequestException as e:
            return {
                'detected': False,
                'wafs': [],
                'confidence': 0,
                'error': str(e),
                'response': None
            }

    def analyze_response(self, response) -> Dict:
        """Анализ ответа на наличие признаков WAF"""

        detected_wafs = []
        confidence_scores = {}

        # Проверяем каждый известный WAF
        for waf_name, signatures in self.waf_signatures.items():
            score = self.calculate_waf_score(response, signatures)

            if score > 0:
                detected_wafs.append(waf_name)
                confidence_scores[waf_name] = score

        # Сортируем по уровню уверенности
        detected_wafs.sort(key=lambda x: confidence_scores.get(x, 0), reverse=True)

        return {
            'detected': len(detected_wafs) > 0,
            'wafs': detected_wafs,
            'confidence': confidence_scores,
            'response_code': response.status_code,
            'response_headers': dict(response.headers),
            'response_length': len(response.content),
            'server_header': response.headers.get('server', ''),
            'techniques_used': self.get_detection_techniques(response, detected_wafs)
        }

    def calculate_waf_score(self, response, signatures: Dict) -> float:
        """Расчет балла уверенности для конкретного WAF"""
        score = 0.0
        max_score = 10.0

        # Проверка заголовков
        headers_score = self.check_headers(response.headers, signatures.get('headers', {}))
        score += headers_score * 4.0  # Вес заголовков

        # Проверка тела ответа
        body_score = self.check_response_body(response.text, signatures.get('response_body', []))
        score += body_score * 3.0  # Вес тела ответа

        # Проверка кодов ответа
        codes_score = self.check_response_codes(response.status_code, signatures.get('response_codes', []))
        score += codes_score * 2.0  # Вес кодов ответа

        # Проверка по поведению (дополнительные тесты)
        behavior_score = self.check_behavior(response)
        score += behavior_score * 1.0  # Вес поведения

        # Нормализуем score
        normalized_score = min(score, max_score) / max_score

        return normalized_score

    def check_headers(self, headers: Dict, header_patterns: Dict) -> float:
        """Проверка заголовков на соответствие паттернам WAF"""
        score = 0.0
        matches = 0

        for header_name, patterns in header_patterns.items():
            header_value = headers.get(header_name, '').lower()

            for pattern in patterns:
                if pattern == '.*':  # Любое значение
                    if header_value:
                        matches += 1
                        break
                elif re.search(pattern, header_value, re.IGNORECASE):
                    matches += 1
                    break

        if matches > 0:
            score = matches / len(header_patterns) if header_patterns else 0

        return score

    def check_response_body(self, body: str, patterns: List[str]) -> float:
        """Проверка тела ответа на наличие сигнатур WAF"""
        if not patterns:
            return 0.0

        matches = 0
        body_lower = body.lower()

        for pattern in patterns:
            if re.search(pattern, body_lower, re.IGNORECASE):
                matches += 1

        return matches / len(patterns)

    def check_response_codes(self, status_code: int, expected_codes: List[int]) -> float:
        """Проверка кода ответа"""
        if not expected_codes:
            return 0.0

        return 1.0 if status_code in expected_codes else 0.0

    def check_behavior(self, response) -> float:
        """Проверка поведенческих характеристик"""
        score = 0.0

        # Проверяем типичное поведение WAF
        behaviors = [
            # Необычно длинные или сложные заголовки
            lambda r: len(str(r.headers)) > 500,
            # Наличие специальных заголовков безопасности
            lambda r: any(h.lower().startswith('x-') for h in r.headers),
            # Специфичные коды ошибок
            lambda r: r.status_code in [403, 406, 418, 429, 503],
            # Наличие CAPTCHA или блокирующих страниц
            lambda r: any(word in r.text.lower() for word in
                          ['captcha', 'blocked', 'access denied', 'security', 'firewall']),
            # Время ответа (WAF обычно добавляет задержку)
            lambda r: response.elapsed.total_seconds() > 1.0
        ]

        matches = sum(1 for behavior in behaviors if behavior(response))
        score = matches / len(behaviors)

        return score

    def get_detection_techniques(self, response, detected_wafs: List[str]) -> Dict:
        """Определение техник, которые помогли обнаружить WAF"""
        techniques = {}

        for waf in detected_wafs:
            waf_techniques = []
            signatures = self.waf_signatures.get(waf, {})

            # Проверяем заголовки
            for header_name, patterns in signatures.get('headers', {}).items():
                header_value = response.headers.get(header_name, '')
                for pattern in patterns:
                    if pattern == '.*' and header_value:
                        waf_techniques.append(f"header:{header_name}")
                        break
                    elif re.search(pattern, header_value, re.IGNORECASE):
                        waf_techniques.append(f"header:{header_name}={header_value[:50]}")
                        break

            # Проверяем тело ответа
            for pattern in signatures.get('response_body', []):
                if re.search(pattern, response.text, re.IGNORECASE):
                    waf_techniques.append(f"body_pattern:{pattern[:30]}")

            # Проверяем код ответа
            if response.status_code in signatures.get('response_codes', []):
                waf_techniques.append(f"status_code:{response.status_code}")

            techniques[waf] = waf_techniques

        return techniques

    def fingerprint_waf(self, url: str) -> Dict:
        """Подробное фингерпринтинг WAF"""
        test_payloads = [
            "<script>alert('test')</script>",
            "' OR '1'='1",
            "../../etc/passwd",
            "<img src=x onerror=alert(1)>",
            "SELECT * FROM users"
        ]

        results = []
        waf_responses = {}

        for payload in test_payloads:
            test_url = f"{url}?test={payload}" if '?' not in url else f"{url}&test={payload}"

            try:
                response = requests.get(test_url, timeout=5)

                waf_responses[payload] = {
                    'status_code': response.status_code,
                    'headers': dict(response.headers),
                    'body_length': len(response.content),
                    'blocked': self.is_blocked(response)
                }

            except Exception as e:
                waf_responses[payload] = {'error': str(e)}

        # Анализируем все ответы
        detection_result = self.detect(url)

        return {
            'basic_detection': detection_result,
            'waf_responses': waf_responses,
            'fingerprint': self.generate_fingerprint(waf_responses),
            'recommendations': self.generate_recommendations(detection_result)
        }

    def is_blocked(self, response) -> bool:
        """Определение, был ли запрос заблокирован"""
        blocked_codes = [403, 406, 418, 429, 503]

        if response.status_code in blocked_codes:
            return True

        # Проверяем типичные фразы блокировки
        block_phrases = [
            'blocked', 'access denied', 'forbidden',
            'security', 'firewall', 'not allowed',
            'malicious', 'suspicious', 'attack'
        ]

        body_lower = response.text.lower()
        return any(phrase in body_lower for phrase in block_phrases)

    def generate_fingerprint(self, waf_responses: Dict) -> Dict:
        """Генерация фингерпринта WAF на основе ответов"""
        fingerprint = {
            'response_patterns': {},
            'blocking_behavior': {},
            'signatures': {}
        }

        for payload, response in waf_responses.items():
            if 'error' not in response:
                pattern_key = f"payload_{payload[:20]}"
                fingerprint['response_patterns'][pattern_key] = {
                    'status': response.get('status_code'),
                    'blocked': response.get('blocked', False),
                    'body_length': response.get('body_length')
                }

        return fingerprint

    def generate_recommendations(self, detection_result: Dict) -> List[str]:
        """Генерация рекомендаций по обходу обнаруженного WAF"""
        recommendations = []
        wafs = detection_result.get('wafs', [])

        if 'Cloudflare' in wafs:
            recommendations.extend([
                "Используйте кодирование UTF-7 для обхода фильтрации",
                "Попробуйте использовать DOM-based XSS вместо reflected",
                "Добавьте заголовок X-Forwarded-For с локальным IP",
                "Используйте медленную атаку с задержками между запросами"
            ])

        if 'ModSecurity' in wafs:
            recommendations.extend([
                "Используйте обфускацию через HTML/URL кодирование",
                "Попробуйте разбить payload на несколько параметров",
                "Используйте альтернативные теги (svg, math, etc.)",
                "Проверьте возможность обхода через заголовки HTTP"
            ])

        if 'AWS WAF' in wafs:
            recommendations.extend([
                "Используйте регистронезависимые payloads",
                "Попробуйте использовать Unicode символы",
                "Разделите атаку на несколько запросов",
                "Используйте медленные POST запросы"
            ])

        if not recommendations:
            recommendations.append("Проведите дополнительные тесты для определения уязвимостей WAF")

        return recommendations